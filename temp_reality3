#!/usr/bin/env bash
set -euo pipefail

# ==========================================
# 基础变量声明与环境准备
# ==========================================
SBOX_ARCH="";            OS_DISPLAY="";          SBOX_CORE="/etc/sing-box/core_script.sh";    ARGO_DOMAIN=""; ARGO_TOKEN=""
SBOX_GOLIMIT="48MiB";    SBOX_GOGC="100";        SBOX_MEM_MAX="55M";     SBOX_OPTIMIZE_LEVEL="未检测";        USE_EXTERNAL_ARGO="false"
SBOX_MEM_HIGH="42M";     CPU_CORE="1";           INITCWND_DONE="false";  VAR_DEF_MEM="";      PORT_HY2="";   PORT_REALITY=""
VAR_UDP_RMEM="";         VAR_UDP_WMEM="";        VAR_SYSTEMD_NICE="";    VAR_HY2_BW="200";    RAW_ECH=""
VAR_SYSTEMD_IOSCHED="";  SWAPPINESS_VAL="10";    BUSY_POLL_VAL="0";      VAR_BACKLOG="5000";  UDP_MEM_SCALE=""

TLS_DOMAIN_POOL=("www.bing.com" "www.microsoft.com" "itunes.apple.com" "www.icloud.com" "www.ebay.com" "www.paypal.com")
pick_tls_domain() { echo "${TLS_DOMAIN_POOL[$RANDOM % ${#TLS_DOMAIN_POOL[@]}]}"; }
TLS_DOMAIN="$(pick_tls_domain)"

# ==========================================
# 彩色输出与工具函数
# ==========================================
info() { echo -e "\033[1;34m[INFO]\033[0m $*"; }; warn() { echo -e "\033[1;33m[WARN]\033[0m $*"; }; err() { echo -e "\033[1;31m[ERR]\033[0m $*" >&2; }; succ() { echo -e "\033[1;32m[OK]\033[0m $*"; }

# OSC 52 自动复制到剪贴板函数 (支持多行)
copy_to_clipboard() {
    local content="$1"
    if [ -n "${SSH_TTY:-}" ] || [ -n "${DISPLAY:-}" ]; then
        local b64_content=$(printf "%b" "$content" | base64 | tr -d '\r\n')
        echo -ne "\033]52;c;${b64_content}\a"
        echo -e "\033[1;32m[复制]\033[0m 节点链接已推送至本地剪贴板"
    fi
}

# 侦测系统类型
detect_os() {
    if [ -f /etc/os-release ]; then . /etc/os-release; OS_DISPLAY="${PRETTY_NAME:-$ID}"; ID="${ID:-}"; ID_LIKE="${ID_LIKE:-}"; else OS_DISPLAY="Unknown Linux"; ID="unknown"; ID_LIKE=""; fi
    # 增强判定逻辑
    if [ -f /etc/alpine-release ]; then OS="alpine"; elif [ -f /etc/debian_version ]; then OS="debian"; elif [ -f /etc/redhat-release ]; then OS="redhat"; else
        local COMBINED="${ID} ${ID_LIKE}"; case "$COMBINED" in *[Aa][Ll][Pp][Ii][Nn][Ee]*) OS="alpine" ;; *[Dd][Ee][Bb][Ii][Aa][Nn]*|*[Uu][Bb][Uu][Nn][Tt][Uu]*) OS="debian" ;; *[Cc][Ee][Nn][Tt][Oo][Ss]*|*[Rr][Hh][Ee][Ll]*|*[Ff][Ee][Dd][Oo][Rr][Aa]*) OS="redhat" ;; *) OS="unknown" ;; esac
    fi
    # 环境修复与架构匹配
    [ "$OS" = "alpine" ] && { [ -x /sbin/syslogd ] && [ ! -f /var/run/syslogd.pid ] && syslogd >/dev/null 2>&1 || true; }
    case "$(uname -m)" in x86_64) SBOX_ARCH="amd64" ;; aarch64) SBOX_ARCH="arm64" ;; armv7l) SBOX_ARCH="armv7" ;; i386|i686) SBOX_ARCH="386" ;; *) err "不支持的架构: $(uname -m)"; exit 1 ;; esac
}

# 依赖安装 (容错增强版)
install_dependencies() {
    info "正在检查系统类型..."
    local PM="" DEPS="curl jq openssl ca-certificates bash tzdata tar iproute2 iptables procps netcat-openbsd" OPT="ethtool kmod wireguard-tools"
    if command -v apk >/dev/null 2>&1; then PM="apk"; DEPS="$DEPS coreutils util-linux-misc"
    elif command -v apt-get >/dev/null 2>&1; then PM="apt"; DEPS="$DEPS util-linux"
    else PM="yum"; DEPS="${DEPS//netcat-openbsd/nc}"; DEPS="${DEPS//procps/procps-ng} util-linux"; fi
    [ -w /proc/sys/vm/drop_caches ] && sync && echo 3 > /proc/sys/vm/drop_caches 2>/dev/null || true
    case "$PM" in
        apk) info "检测到 Alpine 系统，执行分批安装依赖..."
             apk update >/dev/null 2>&1
             local missing=""; for pkg in $DEPS; do apk info -e "$pkg" >/dev/null || missing="$missing $pkg"; done
             [ -n "$missing" ] && apk add --no-cache $missing || warn "部分组件安装异常"
             missing=""; for pkg in $OPT; do apk info -e "$pkg" >/dev/null || missing="$missing $pkg"; done
             [ -n "$missing" ] && apk add --no-cache $missing >/dev/null 2>&1 || true
             rm -rf /var/cache/apk/* ;;
        apt) info "检测到 Debian/Ubuntu 系统，正在更新源并安装依赖..."
             export DEBIAN_FRONTEND=noninteractive
             apt-get update -y >/dev/null 2>&1
             apt-get install -y --no-install-recommends $DEPS || err "依赖安装失败"
             apt-get install -y --no-install-recommends $OPT >/dev/null 2>&1 || true
             apt-get clean; rm -rf /var/lib/apt/lists/* ;;
        yum) info "检测到 RHEL/CentOS 系统，正在同步仓库并安装依赖..."
             $(command -v dnf || echo "yum") install -y $DEPS || err "依赖安装失败"
             $(command -v dnf || echo "yum") install -y $OPT >/dev/null 2>&1 || true ;;
    esac
    update-ca-certificates 2>/dev/null || true
    for cmd in jq curl tar bash pgrep taskset; do command -v "$cmd" >/dev/null 2>&1 || { [ "$PM" = "apk" ] && apk add --no-cache util-linux >/dev/null 2>&1 || { err "核心依赖 ${cmd} 安装失败，请检查网络或源"; exit 1; }; } done
    succ "所需依赖已就绪"
}

# 检测CPU核心数
get_cpu_core() {
    local n q p c; n=$(nproc 2>/dev/null || grep -c ^processor /proc/cpuinfo || echo 1)
    if [ -r /sys/fs/cgroup/cpu.max ]; then
        read -r q p < /sys/fs/cgroup/cpu.max
    else
        q=$(cat /sys/fs/cgroup/cpu/cpu.cfs_quota_us 2>/dev/null)
        p=$(cat /sys/fs/cgroup/cpu/cpu.cfs_period_us 2>/dev/null)
    fi
    if [[ "${q:-}" =~ ^[0-9]+$ ]] && [ "$q" -gt 0 ]; then
        p=${p:-100000}; c=$(( q / p )); [ "$c" -le 0 ] && c=1
        echo $(( c < n ? c : n ))
    else echo "$n"; fi
}

# 获取并校验端口 (范围：1025-65535)
prompt_for_port() {
    local p rand
    while :; do
        read -r -p "请输入端口 [1025-65535] (回车随机生成): " p
        if [ -z "$p" ]; then
            if command -v shuf >/dev/null 2>&1; then p=$(shuf -i 1025-65535 -n 1)
            elif [ -r /dev/urandom ] && command -v od >/dev/null 2>&1; then rand=$(od -An -N2 -tu2 /dev/urandom | tr -d ' '); p=$((1025 + rand % 64511))
            else p=$((1025 + RANDOM % 64511)); fi
        fi
        if [[ "$p" =~ ^[0-9]+$ ]] && [ "$p" -ge 1025 ] && [ "$p" -le 65535 ]; then
            local occupied=""
            if command -v ss >/dev/null 2>&1; then occupied=$(ss -tunlp | grep -w ":$p")
            elif command -v netstat >/dev/null 2>&1; then occupied=$(netstat -tunlp | grep -w ":$p")
            elif command -v lsof >/dev/null 2>&1; then occupied=$(lsof -i :"$p")
            fi
            if [ -n "$occupied" ]; then
                echo -e "\033[1;33m[WARN]\033[0m 端口 $p 已被占用，请更换端口或直接回车重新生成" >&2
                p=""; continue
            fi
            echo -e "\033[1;32m[INFO]\033[0m 使用端口: $p" >&2
            echo "$p"; return 0
        else echo -e "\033[1;31m[错误]\033[0m 端口无效，请输入1025-65535之间的数字" >&2; fi
    done
}

# 创建 Argo 隧道
setup_argo_logic() {
    local argo_d argo_t mem_total=$(probe_memory_total); : ${mem_total:=64}
    echo -e "\033[1;32m[可选配置]\033[0m\nVLESS + HttpUpgrade + Argo: CF隧道转发\n-----------------------------------------------" >&2
    echo -ne "\033[1;36m[Argo 设置]\033[0m 请输入域名 (直接回车跳过可选配置): " >&2; read -r argo_d
    if [ -z "$argo_d" ]; then ARGO_DOMAIN=""; ARGO_TOKEN=""; USE_EXTERNAL_ARGO="false"; echo -e "\033[1;32m[INFO]\033[0m 已跳过 Argo 配置" >&2
    elif [ "$mem_total" -lt 150 ] && ! /usr/bin/sing-box version 2>/dev/null | grep -q "with_cloudflare"; then
        ARGO_DOMAIN=""; ARGO_TOKEN=""; USE_EXTERNAL_ARGO="false"
        echo -e "\033[1;33m[跳过]\033[0m 内存不足 200M 且内核不支持内建 Argo，为保系统稳定已自动跳过" >&2
    else
        while :; do
            echo -ne "请输入 Argo 隧道的 Token: " >&2; read -r argo_t
            if [ -z "$argo_t" ]; then echo -e "\033[1;33m[WARN]\033[0m Token 不能为空" >&2; continue; fi
            ARGO_DOMAIN="$argo_d"; ARGO_TOKEN="$argo_t"
            if /usr/bin/sing-box version 2>/dev/null | grep -q "with_cloudflare"; then
                USE_EXTERNAL_ARGO="false"; echo -e "\033[1;32m[INFO]\033[0m 检测到内核支持内建 Argo，开启单进程模式" >&2
            elif [ -f "/usr/local/bin/cloudflared" ]; then
                USE_EXTERNAL_ARGO="true"; echo -e "\033[1;33m[INFO]\033[0m 已存在外部客户端，跳过下载" >&2
            else
                USE_EXTERNAL_ARGO="true"; echo -ne "\033[1;32m[INFO]\033[0m 下载官方 cloudflared... " >&2
                wget -qO /usr/local/bin/cloudflared https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64 && chmod +x /usr/local/bin/cloudflared && echo -e "\033[1;32m[完成]\033[0m" >&2 || { echo -e "\033[1;31m[失败]\033[0m" >&2; exit 1; }
            fi; break
        done
    fi
}

# 生成 ECC P-256 高性能证书 + ECH 密钥对
generate_cert() {
    local CERT_DIR="/etc/sing-box/certs"; local TMP_ECH="$CERT_DIR/ech_out.tmp"; local cert_mode=""
    mkdir -p "$CERT_DIR" && chmod 700 "$CERT_DIR"
    while :; do
        echo -e "\n\033[1;36m[证书配置]\033[0m 请选择 TLS 证书来源："
        echo "1. 自动生成自签证书 (默认，适用于无域名用户)"
        echo "2. 手动粘贴 Cloudflare 证书 (适用于已在 CF 开启自定义域名的用户)"
        read -r -p "请输入选项 [1-2] (默认1): " cert_mode; cert_mode=${cert_mode:-1}
        [[ "$cert_mode" =~ ^[1-2]$ ]] && break || err "输入错误，请输入 1 或 2"
    done
	
    if [ "$cert_mode" = "2" ]; then
        while :; do
            read -r -p "请输入您在 CF 解析的域名 (例如: hy2.example.com): " USER_SNI
            [ -n "$USER_SNI" ] && { TLS_DOMAIN="$USER_SNI"; break; } || err "域名不能为空"
        done
        info "准备接收证书与私钥内容..."
        echo -e "请将 CF 的 [Origin Certificate] 和 [Private Key] 粘贴到下方，然后按下 [回车]，再按 [Ctrl+D] 完成提交："
        local TMP_PEM="$CERT_DIR/input.tmp"
        cat > "$TMP_PEM"
        sed -n '/-----BEGIN CERTIFICATE-----/,/-----END CERTIFICATE-----/p' "$TMP_PEM" > "$CERT_DIR/fullchain.pem"
        sed -n '/-----BEGIN \(.*\)PRIVATE KEY-----/,/-----END \(.*\)PRIVATE KEY-----/p' "$TMP_PEM" > "$CERT_DIR/privkey.pem"
        rm -f "$TMP_PEM"
        if [ -s "$CERT_DIR/fullchain.pem" ] && [ -s "$CERT_DIR/privkey.pem" ]; then succ "已自动识别并分离证书与私钥"
        else err "识别失败：未在内容中找到合规的 PEM 块"; exit 1; fi
        succ "所有敏感信息已安全存储并锁死权限 (600)"
    else
        info "生成 ECC 证书 (域名: $TLS_DOMAIN)..."
        openssl req -x509 -newkey ec -pkeyopt ec_paramgen_curve:prime256v1 -nodes \
            -keyout "$CERT_DIR/privkey.pem" -out "$CERT_DIR/fullchain.pem" \
            -days 3650 -sha256 -subj "/CN=$TLS_DOMAIN" \
            -addext "basicConstraints=critical,CA:FALSE" \
            -addext "subjectAltName=DNS:$TLS_DOMAIN" \
            -addext "extendedKeyUsage=serverAuth" &>/dev/null
    fi
	
    # 生成 ECH 密钥 (保持原有逻辑)
    info "生成 $TLS_DOMAIN 的 ECH 密钥对..."
    /usr/bin/sing-box generate ech-keypair "$TLS_DOMAIN" > "$TMP_ECH" 2>&1
    sed -n '/BEGIN ECH KEYS/,/END ECH KEYS/p' "$TMP_ECH" > "$CERT_DIR/ech.key"
    sed -n '/BEGIN ECH CONFIGS/,/END ECH CONFIGS/p' "$TMP_ECH" > "$CERT_DIR/ech.pub"
    rm -f "$TMP_ECH"
    # 校验并提取指纹
    if [ -s "$CERT_DIR/ech.key" ] && [ -s "$CERT_DIR/fullchain.pem" ]; then
        openssl x509 -in "$CERT_DIR/fullchain.pem" -noout -sha256 -fingerprint | sed 's/.*=//; s/://g' | tr '[:upper:]' '[:lower:]' > "$CERT_DIR/cert_fingerprint.txt"
        chmod 600 "$CERT_DIR/privkey.pem" "$CERT_DIR/ech.key" && chmod 644 "$CERT_DIR/fullchain.pem" "$CERT_DIR/ech.pub"
        succ "ECC 证书与 ECH 密钥对就绪"
    else err "证书或 ECH 密钥生成失败"; exit 1; fi
    unset USER_SNI
}

# 获取公网IP(高效稳定探测)
get_network_info() {
    info "获取网络信息..."; RAW_IP4=""; RAW_IP6=""; IS_V6_OK="false"; local t4="/tmp/.v4" t6="/tmp/.v6"
    rm -f "$t4" "$t6"
	
    # 1. 探测函数：v4 用标准接口，v6 用专用 api6 接口，在无 v6 时会秒断，在有 v6 时极稳
    _f() { local p=$1
        { curl $p -ksSfL --connect-timeout 1 --max-time 3 "https://1.1.1.1/cdn-cgi/trace" | awk -F= '/ip/ {print $2}'; } || \
        { [ "$p" = "-4" ] && curl $p -ksSfL --connect-timeout 1 --max-time 2 "https://api.ipify.org" || curl $p -ksSfL --connect-timeout 2 --max-time 4 "https://api6.ipify.org" ; } || \
          curl $p -ksSfL --connect-timeout 1 --max-time 2 "https://icanhazip.com" || echo ""; }
		  
    # 2. 异步执行：并行探测
    _f -4 >"$t4" 2>/dev/null & p4=$!; _f -6 >"$t6" 2>/dev/null & p6=$!; wait $p4 $p6 2>/dev/null
    # 3. 数据清洗 (融合版)：在主进程统一清洗数据
    [ -s "$t4" ] && read -r RAW_IP4 < "$t4" && RAW_IP4=${RAW_IP4//[[:space:]]/}
    [ -s "$t6" ] && read -r RAW_IP6 < "$t6" && RAW_IP6=${RAW_IP6//[[:space:]]/}
    [[ ! "$RAW_IP4" =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}$ ]] && RAW_IP4=""
    [[ "$RAW_IP6" != *:* ]] && RAW_IP6=""
    rm -f "$t4" "$t6"
    # 4. 判定与输出
    [[ "$RAW_IP6" == *:* ]] && IS_V6_OK="true"
    [ -n "$RAW_IP4" ] && echo -e "\033[1;32m[✔]\033[0m IPv4: \033[1;37m$RAW_IP4\033[0m" || echo -e "\033[1;31m[✖]\033[0m IPv4: \033[1;31m不可用\033[0m"
    [ "$IS_V6_OK" = "true" ] && echo -e "\033[1;32m[✔]\033[0m IPv6: \033[1;37m$RAW_IP6\033[0m" || echo -e "\033[1;31m[✖]\033[0m IPv6: \033[1;31m不可用\033[0m"
    [ -z "$RAW_IP4" ] && [ -z "$RAW_IP6" ] && { err "错误: 未能探测到公网 IP"; exit 1; } || return 0
}

# 网络延迟探测模块
probe_network_rtt() {
    local rtt_val; local loss_val="5"; local real_rtt_factors="130"; local loss_compensation="100"; set +e
    echo -e "\033[1;34m[INFO]\033[0m 正在探测网络画像 (RTT/丢包)..." >&2
	# 1. 扩充探测池：覆盖国内骨干、全球顶级 CDN 及 DNS 节点
    local targets=("223.5.5.5" "119.29.29.29" "114.114.114.114" "1.1.1.1" "8.8.8.8" "8.26.56.26" "208.67.222.222")
    local ping_res=""
	# 2. 遍历探测：获取首个有效响应，平衡探测速度与覆盖广度
    for target in "${targets[@]}"; do
        local res=$(ping -c 5 -W 1 "$target" 2>/dev/null)
        if echo "$res" | grep -q "received"; then ping_res="$res"; break; fi
    done
	# 3. 提取平均 RTT 并解析丢包率 (兼容多系统格式)
    if [ -n "$ping_res" ]; then
        rtt_val=$(echo "$ping_res" | awk -F'/' 'END{print int($5)}')
        loss_val=$(echo "$ping_res" | grep -oE '[0-9]+% packet loss' | grep -oE '[0-9]+' || echo "5")
        echo -e "\033[1;32m[OK]\033[0m 实测 RTT: ${rtt_val}ms | 丢包: ${loss_val}%" >&2
    else
        rtt_val="150"; echo -e "\033[1;33m[WARN]\033[0m 探测受阻，应用全球预估值: 150ms" >&2
    fi
    set -e
    # 画像联动赋值
    real_rtt_factors=$(( rtt_val + 100 ))   # 延迟补偿：实测值 + 100ms (平衡握手开销)
	# 丢包补偿：每 1% 丢包增加 5% 缓冲区冗余，最高 200%
    loss_compensation=$(( 100 + loss_val * 5 )); [ "$loss_compensation" -gt 200 ] && loss_compensation=200
	# 输出原始 RTT 供脚本其它函数引用
    echo "$rtt_val" "$real_rtt_factors" "$loss_compensation"
}

# 内存资源探测模块
probe_memory_total() {
    local mem_total=64 mem_cgroup=0
    local mem_host_total=$(free -m | awk '/Mem:/ {print $2}' | tr -cd '0-9')
    # 1. 优先级探测: Cgroup v1 -> Cgroup v2 -> /proc/meminfo
    if [ -f /sys/fs/cgroup/memory/memory.limit_in_bytes ]; then
        local m_limit=$(cat /sys/fs/cgroup/memory/memory.limit_in_bytes | tr -cd '0-9')
        [ "${#m_limit}" -lt 15 ] && mem_cgroup=$((m_limit / 1024 / 1024))
    elif [ -f /sys/fs/cgroup/memory.max ]; then
        local m_max=$(cat /sys/fs/cgroup/memory.max | tr -cd '0-9')
        [ -n "$m_max" ] && mem_cgroup=$((m_max / 1024 / 1024))
    elif grep -q "MemTotal" /proc/meminfo; then
        mem_cgroup=$(awk '/MemTotal/ {print int($2/1024)}' /proc/meminfo)
    fi
    # 2. 内存边界判定与特殊虚拟化 (OpenVZ) 修正
    [ "$mem_cgroup" -gt 0 ] && [ "$mem_cgroup" -le "$mem_host_total" ] && mem_total=$mem_cgroup || mem_total=$mem_host_total
    [ -f /proc/user_beancounters ] && mem_total=$mem_host_total
    # 3. 最终异常值校验 (兜底 64MB)
    ([ -z "$mem_total" ] || [ "$mem_total" -le 0 ] || [ "$mem_total" -gt 64000 ]) && mem_total=64
    echo "$mem_total"
}

# InitCWND 专项优化模块 (取黄金分割点 15 ，比默认 10 强 50%，比 20 更隐蔽)
apply_initcwnd_optimization() {
    local silent="${1:-false}" info gw dev mtu mss opts
    command -v ip >/dev/null || return 0
    local current_route=$(ip route show default | head -n1)
    echo "$current_route" | grep -q "initcwnd 15" && { [[ "$silent" == "false" ]] && info "InitCWND 已优化，跳过"; INITCWND_DONE="true"; return 0; }
    gw=$(echo "$current_route" | grep -oE 'via [^ ]+' | awk '{print $2}')
    dev=$(echo "$current_route" | grep -oE 'dev [^ ]+' | awk '{print $2}')
    mtu=$(echo "$current_route" | grep -oE 'mtu [0-9]+' | awk '{print $2}' || echo 1500)
    mss=$((mtu - 40))
    opts="initcwnd 15 initrwnd 15 advmss $mss"

    if ip route change default $(echo "$current_route" | cut -d' ' -f2-) 2>/dev/null; then
        if { [ -n "$gw" ] && [ -n "$dev" ] && ip route change default via "$gw" dev "$dev" $opts 2>/dev/null; } || \
           { [ -n "$gw" ] && [ -n "$dev" ] && ip route replace default via "$gw" dev "$dev" $opts 2>/dev/null; } || \
           { [ -n "$dev" ] && ip route replace default dev "$dev" $opts 2>/dev/null; } || \
           ip route change default $opts 2>/dev/null; then
            INITCWND_DONE="true"
            [[ "$silent" == "false" ]] && succ "InitCWND 优化成功 (15/MSS $mss)"
        fi
    else
        INITCWND_DONE="false"
        [[ "$silent" == "false" ]] && warn "InitCWND 修改受限，维持系统默认 (10)"
    fi
}

# ZRAM/Swap 智能配置
setup_zrm_swap() {
    local mt="$1" zs z_bytes st algo="lz4"
    { [ -z "$mt" ] || [ "$mt" -ge 600 ]; } && return 0
    grep -q "zram0" /proc/swaps && { info "ZRAM 已就绪"; return 0; }
	
    if ! modprobe zram 2>/dev/null; then [ "$OS" = "alpine" ] && apk add linux-virt-modules >/dev/null 2>&1 && modprobe zram 2>/dev/null; fi
    if ! modprobe zram 2>/dev/null; then warn "内核不支持 ZRAM"; elif [ ! -b /dev/zram0 ]; then warn "未发现 ZRAM 设备"; else
        if ! echo 1 > /sys/block/zram0/reset 2>/dev/null; then warn "容器限制，ZRAM 不可用"; else
            zs=$((mt * 15 / 10)); [ "$zs" -gt 512 ] && zs=512; z_bytes=$((zs * 1024 * 1024))
            [ -f /sys/block/zram0/comp_algorithm ] && { grep -qw lz4 /sys/block/zram0/comp_algorithm && algo="lz4" || algo="lzo"; echo "$algo" > /sys/block/zram0/comp_algorithm 2>/dev/null || true; }
            if echo "$z_bytes" > /sys/block/zram0/disksize 2>/dev/null && mkswap /dev/zram0 >/dev/null 2>&1 && swapon -p 10 /dev/zram0 2>/dev/null; then
                succ "ZRAM 激活: ${zs}M ($algo)"; [ "$mt" -le 128 ] && sysctl -w vm.swappiness=80 >/dev/null 2>&1
                if command -v systemctl >/dev/null 2>&1; then
                    cat > /etc/systemd/system/zram-swap.service <<EOF
[Unit]
Description=ZRAM Swap
Before=sing-box.service
[Service]
Type=oneshot
RemainAfterExit=yes
ExecStart=/bin/sh -c 'modprobe zram; echo $algo > /sys/block/zram0/comp_algorithm; echo $z_bytes > /sys/block/zram0/disksize; mkswap /dev/zram0; swapon -p 10 /dev/zram0'
ExecStop=/sbin/swapoff /dev/zram0
[Install]
WantedBy=multi-user.target
EOF
                    systemctl daemon-reload && systemctl enable zram-swap.service 2>/dev/null
                elif [ "$OS" = "alpine" ]; then
                    cat > /etc/init.d/zram-swap <<EOF
#!/sbin/openrc-run
start() { modprobe zram; echo $algo > /sys/block/zram0/comp_algorithm; echo $z_bytes > /sys/block/zram0/disksize; mkswap /dev/zram0 && swapon -p 10 /dev/zram0; }
stop() { swapoff /dev/zram0; echo 1 > /sys/block/zram0/reset; }
EOF
                    chmod +x /etc/init.d/zram-swap && rc-update add zram-swap default 2>/dev/null
                fi; return 0
            else warn "ZRAM 初始化失败"; fi
        fi
    fi
	# 磁盘 Swap 兜底 (仅在 ZRAM 失败且非 Alpine 时)
    [ "$OS" = "alpine" ] && { info "Alpine 跳过磁盘 Swap"; return 0; }
	local st=$(grep "SwapTotal" /proc/meminfo | awk '{print $2}')
    if [ "${st:-0}" -eq 0 ] && [ ! -d /proc/vz ]; then
        info "创建磁盘 Swap (512M)..."
        if (fallocate -l 512M /swapfile 2>/dev/null || dd if=/dev/zero of=/swapfile bs=1M count=512 2>/dev/null) && chmod 600 /swapfile && mkswap /swapfile >/dev/null 2>&1 && swapon -p 5 /swapfile 2>/dev/null; then
            grep -q "/swapfile" /etc/fstab || echo "/swapfile swap swap pri=5 0 0" >> /etc/fstab && succ "磁盘 Swap 已激活"
        else rm -f /swapfile 2>/dev/null; warn "磁盘 Swap 创建失败"; fi
    fi
}

# 动态 RTT 内存页钳位
safe_rtt() {
    local dyn_buf="$1" rtt_val="$2" max_udp_pages="$3" udp_min="$4" udp_pre="$5" udp_max="$6" real_rtt_factors="$7" loss_compensation="$8"
    local dyn_pages=$(( dyn_buf / 4096 )); local probe_pages=$(( real_rtt_factors * 1024 * loss_compensation / 100 ))
    # 1. 基础仲裁
    rtt_scale_max=$(( probe_pages > dyn_pages ? probe_pages : dyn_pages ))
    # 2. 补偿逻辑 (增加小内存防溢出：100M- 小鸡 max_udp_pages 通常 < 16384)
    if [ "$rtt_val" -ge 150 ]; then
        local factor=15; [ "$max_udp_pages" -le 16384 ] && factor=12
        rtt_scale_max=$(( rtt_scale_max * factor / 10 )); SBOX_OPTIMIZE_LEVEL="${SBOX_OPTIMIZE_LEVEL} (QUIC远航)"
    else SBOX_OPTIMIZE_LEVEL="${SBOX_OPTIMIZE_LEVEL} (QUIC竞速)"; fi
    # 3. 三级梯度生成 (0.75 : 0.9 : 1.0)
    rtt_scale_pressure=$(( rtt_scale_max * 90 / 100 )); rtt_scale_min=$(( rtt_scale_max * 75 / 100 ))
    # 4. 档位钳位与物理上限终极对齐 (确保不穿透物理防线)
    [ "$rtt_scale_max" -gt "$max_udp_pages" ] && { rtt_scale_max=$max_udp_pages; rtt_scale_pressure=$(( max_udp_pages * 95 / 100 )); rtt_scale_min=$(( max_udp_pages * 80 / 100 )); }
    rtt_scale_max=$(( rtt_scale_max < udp_max ? rtt_scale_max : udp_max ))
    rtt_scale_pressure=$(( rtt_scale_pressure < udp_pre ? rtt_scale_pressure : udp_pre ))
    rtt_scale_min=$(( rtt_scale_min < udp_min ? rtt_scale_min : udp_min ))
}

# sing-box 用户态运行时调度人格（Go/QUIC/缓冲区自适应）
apply_userspace_adaptive_profile() {
    local g_procs="$1" wnd="$2" buf="$3" real_c="$4" mem_total="$5"
    # 内存回收策略：100M- 采用极度激进模式，确保内存页立即归还内核
    if [ "$mem_total" -lt 100 ]; then
        export GOMAXPROCS=1
        export GODEBUG="madvdontneed=1,scavenge_target=1"
        local sl=$(( mem_total * 65 / 100 )); [ "$sl" -lt 32 ] && sl=32
        GOMEMLIMIT="${sl}MiB"; GOGC="50"
        info "Runtime → 激进回收模式 (100M- 适配版)"
    else
        export GOMAXPROCS="$g_procs"
        export GODEBUG="madvdontneed=1,asyncpreemptoff=1"
        GOMEMLIMIT="${SBOX_GOLIMIT:-48MiB}"; GOGC="${SBOX_GOGC:-100}"
        info "Runtime → 性能优先模式"
    fi
	
    export GOMEMLIMIT GOGC SINGBOX_QUIC_MAX_CONN_WINDOW="$wnd" VAR_HY2_BW="${VAR_HY2_BW:-200}" SINGBOX_UDP_RECVBUF="$buf" SINGBOX_UDP_SENDBUF="$buf"
    mkdir -p /etc/sing-box; cat > /etc/sing-box/env <<EOF
GOMAXPROCS=$GOMAXPROCS
GOGC=$GOGC
GOMEMLIMIT=$GOMEMLIMIT
GODEBUG=$GODEBUG
SINGBOX_QUIC_MAX_CONN_WINDOW=$SINGBOX_QUIC_MAX_CONN_WINDOW
SINGBOX_UDP_RECVBUF=$buf
SINGBOX_UDP_SENDBUF=$buf
VAR_HY2_BW=$VAR_HY2_BW
EOF
    chmod 644 /etc/sing-box/env
	
    # 4. CPU 亲和力 (仅多核且存在 taskset 时优化)
    [ "$real_c" -gt 1 ] && command -v taskset >/dev/null 2>&1 && taskset -pc 0-$((real_c - 1)) $$ >/dev/null 2>&1
    info "Runtime → GOMAXPROCS: $GOMAXPROCS 核 | 内存限额: $GOMEMLIMIT | GOGC: $GOGC | Buffer: $((buf/1024)) KB"
}

# 网卡核心负载加速（RPS/XPS/批处理密度）
apply_nic_core_boost() {
    # 1. 寻找默认出口网卡
    local IFACE=$(ip route show default 2>/dev/null | awk '/default/{print $5; exit}')
    [ -z "$IFACE" ] && return 0
    local real_c="$1" bgt="$2" usc="$3" mem_total="$4" target_qlen="$5" t_usc="$6" ring="$7" driver=""
    # 2. 内核软中断预算优化
    sysctl -w net.core.netdev_budget="$bgt" net.core.netdev_budget_usecs="$usc" >/dev/null 2>&1 || true
    # 3. 驱动识别与发送队列 (TXQLEN) 动态调整
    [ -L "/sys/class/net/$IFACE/device/driver" ] && driver=$(basename "$(readlink "/sys/class/net/$IFACE/device/driver")")
    # 4. 针对虚拟化环境的二度钳位 (在传入的 target_qlen 基础上判断)
    case "$driver" in
        virtio_net|veth|"") target_qlen=$((target_qlen / 2)) ;;
        *) : ;;
    esac
    # 5. 链路层特征与硬件卸载优化
    if [ -d "/sys/class/net/$IFACE" ]; then
        ip link set dev "$IFACE" txqueuelen "$target_qlen" 2>/dev/null || true     
        if command -v ethtool >/dev/null 2>&1; then
            ethtool -K "$IFACE" gro on gso on tso on lro off 2>/dev/null || true
            ethtool -C "$IFACE" rx-usecs "$t_usc" tx-usecs "$t_usc" 2>/dev/null || true
            ethtool -G "$IFACE" rx "$ring" tx "$ring" 2>/dev/null || true
        fi
    fi
    # 6. 多核分发优化 (RPS/XPS)
    if [ "$real_c" -ge 2 ] && [ -d "/sys/class/net/$IFACE/queues" ]; then
        local MASK=$(printf '%x' $(( (1<<real_c)-1 )))
        for q in /sys/class/net/"$IFACE"/queues/rx-*/rps_cpus; do
            [ -w "$q" ] && echo "$MASK" > "$q" 2>/dev/null || true
        done
        for q in /sys/class/net/"$IFACE"/queues/tx-*/xps_cpus; do
            [ -w "$q" ] && echo "$MASK" > "$q" 2>/dev/null || true
        done
    fi
    info "NIC 优化 → 网卡: $IFACE | 队列: $target_qlen | 中断延迟: ${t_usc}us | 环形缓冲区: $ring"
}

# 配置预检
verify_config() {
    local LOG="/tmp/sb_check.log"; info "执行配置合规性检查..."
    if /usr/bin/sing-box check -c /etc/sing-box/config.json >"$LOG" 2>&1; then
        succ "配置预检通过" && { rm -f "$LOG"; return 0; }
    else
        echo -e "\033[1;31m[!]\033[0m 错误详情: $(tail -n 1 "$LOG" 2>/dev/null)"
        err "配置预检失败，拒绝应用变更！" && { rm -f "$LOG"; return 1; }
    fi
}

# 防火墙开放端口
apply_firewall() {
    local p_hy2=$(jq -r '..|objects|select(.tag=="hy2-in")|.listen_port//empty' /etc/sing-box/config.json 2>/dev/null)
    local p_rea=$(jq -r '..|objects|select(.tag=="vless-reality-in")|.listen_port//empty' /etc/sing-box/config.json 2>/dev/null)
    _add_rule() { [ -n "$1" ] && iptables -I INPUT -p "$2" --dport "$1" -j ACCEPT 2>/dev/null; }
    _add_rule "$p_hy2" "udp"
    _add_rule "$p_rea" "tcp"
    command -v ip6tables >/dev/null 2>&1 && {
        [ -n "$p_hy2" ] && ip6tables -I INPUT -p udp --dport "$p_hy2" -j ACCEPT 2>/dev/null
        [ -n "$p_rea" ] && ip6tables -I INPUT -p tcp --dport "$p_rea" -j ACCEPT 2>/dev/null
    } || true
}
	
# "全功能调度器"
service_ctrl() {
    local action="$1"
    [[ "$action" == "restart" ]] && { echo -e "\033[1;32m[INFO]\033[0m 正在应用调优并重启服务，请稍后..."; optimize_system >/dev/null 2>&1 || true; setup_service; apply_firewall; return 0; }
    if [ -x "/etc/init.d/sing-box" ]; then rc-service sing-box "$action"
    else systemctl daemon-reload >/dev/null 2>&1; systemctl "$action" sing-box; fi
}

# ==========================================
# 系统内核优化 (核心逻辑：差异化 + 进程调度 + UDP极限)
# ==========================================
optimize_system() {
    local rtt_res=($(probe_network_rtt)); local mem_total=$(probe_memory_total)
	local rtt_avg="${rtt_res[0]:-150}" real_rtt_factors="${rtt_res[1]:-130}" loss_compensation="${rtt_res[2]:-100}"
    local real_c="$CPU_CORE" ct_max=16384 ct_udp_to=30 ct_stream_to=30
    local dyn_buf g_procs g_wnd g_buf net_bgt net_usc tcp_rmem_max target_qlen t_usc ring
    local max_udp_mb max_udp_pages udp_mem_global_min udp_mem_global_pressure udp_mem_global_max
    local swappiness_val="${SWAPPINESS_VAL:-10}" busy_poll_val="${BUSY_POLL_VAL:-0}"
    
    setup_zrm_swap "$mem_total"
	info "系统画像: CPU核心: ${real_c} 核 | 系统内存: ${mem_total} mb | 平均延迟: ${rtt_avg} ms | RTT补偿: ${real_rtt_factors} ms | 丢包补偿: ${loss_compensation}%"

    # 阶段一： 四档位差异化配置 (精密调优版)
    if [ "$mem_total" -ge 450 ]; then
        VAR_HY2_BW="500"; max_udp_mb=$((mem_total * 60 / 100))
        SBOX_GOLIMIT="$((mem_total * 75 / 100))MiB"; SBOX_GOGC="150"
        SBOX_MEM_HIGH="$((mem_total * 85 / 100))M"; SBOX_MEM_MAX="$((mem_total * 95 / 100))M"
        VAR_SYSTEMD_NICE="-15"; VAR_SYSTEMD_IOSCHED="realtime"; tcp_rmem_max=16777216
        g_procs=$real_c; swappiness_val=10; busy_poll_val=50; ct_max=65535; ct_stream_to=60
		target_qlen=10000; t_usc=100; ring=2048
        SBOX_OPTIMIZE_LEVEL="512M 旗舰版"
    elif [ "$mem_total" -ge 200 ]; then
        VAR_HY2_BW="300"; max_udp_mb=$((mem_total * 55 / 100))
        SBOX_GOLIMIT="$((mem_total * 73 / 100))MiB"; SBOX_GOGC="100"
        SBOX_MEM_HIGH="$((mem_total * 83 / 100))M"; SBOX_MEM_MAX="$((mem_total * 93 / 100))M"
        VAR_SYSTEMD_NICE="-10"; VAR_SYSTEMD_IOSCHED="best-effort"; tcp_rmem_max=8388608
        g_procs=$real_c; swappiness_val=10; busy_poll_val=20; ct_max=32768; ct_stream_to=45
		target_qlen=8000;  t_usc=150; ring=1024
        SBOX_OPTIMIZE_LEVEL="256M 增强版"
    elif [ "$mem_total" -ge 100 ]; then
        VAR_HY2_BW="200"; max_udp_mb=$((mem_total * 50 / 100))
        SBOX_GOLIMIT="$((mem_total * 70 / 100))MiB"; SBOX_GOGC="70"
        SBOX_MEM_HIGH="$((mem_total * 80 / 100))M"; SBOX_MEM_MAX="$((mem_total * 90 / 100))M"
        VAR_SYSTEMD_NICE="-8"; VAR_SYSTEMD_IOSCHED="best-effort"; tcp_rmem_max=4194304
        swappiness_val=10; busy_poll_val=0; ct_max=16384; ct_stream_to=30
        [ "$real_c" -gt 2 ] && g_procs=2 || g_procs=$real_c
		target_qlen=5000;  t_usc=150; ring=1024
        SBOX_OPTIMIZE_LEVEL="128M 紧凑版"
    else
        VAR_HY2_BW="100"; max_udp_mb=$((mem_total * 45 / 100)) 
        SBOX_GOLIMIT="$((mem_total * 65 / 100))MiB"; SBOX_GOGC="50"
        SBOX_MEM_HIGH="$((mem_total * 75 / 100))M"; SBOX_MEM_MAX="$((mem_total * 85 / 100))M"
        VAR_SYSTEMD_NICE="-5"; VAR_SYSTEMD_IOSCHED="best-effort"; tcp_rmem_max=2097152
        g_procs=1; swappiness_val=10; busy_poll_val=0; ct_max=16384; ct_stream_to=30
		target_qlen=2000;  t_usc=250; ring=512
        SBOX_OPTIMIZE_LEVEL="64M 激进版"
    fi

    # 阶段二：[重点] dyn_buf 跳板与带宽灵魂联动
    # 1. 计算带宽所需 BDP 保底 (系数3以应对国际链路抖动)
    local bdp_min=$(( VAR_HY2_BW * 1024 * 1024 / 8 / 5 * 3 )) # 约 0.3s 冗余
    # 2. 设置跳板变量 dyn_buf (综合物理能力与带宽需求)
    dyn_buf=$(( (mem_total << 20) >> 3 ))
    [ "$dyn_buf" -lt "$bdp_min" ] && dyn_buf=$bdp_min
    # 针对 100M- 机器严格锁定上限，防止内存被缓冲区填满导致波浪式掉速
    if [ "$mem_total" -lt 100 ]; then
        [ "$dyn_buf" -gt 8388608 ] && dyn_buf=8388608   # 强制上限 8MB，维持高周转
        [ "$dyn_buf" -lt 4194304 ] && dyn_buf=4194304   # 保底 4MB
    else
        [ "$mem_total" -ge 200 ] && [ "$dyn_buf" -lt 33554432 ] && dyn_buf=33554432
        [ "$dyn_buf" -lt 16777216 ] && dyn_buf=16777216
    fi
    [ "$dyn_buf" -gt 67108864 ] && dyn_buf=67108864
    # 3. 所有内核网络参数基于 dyn_buf 伸缩
    VAR_UDP_RMEM="$dyn_buf"; VAR_UDP_WMEM="$dyn_buf"
    VAR_DEF_MEM=$(( dyn_buf / 4 ))
    VAR_BACKLOG=$(( VAR_HY2_BW * 50 ))   # 队列从30提到50，抗突发丢包
    [ "$VAR_BACKLOG" -lt 8192 ] && VAR_BACKLOG=8192
    # 4. 联动导出：Sing-box 应用层参数
    g_wnd=$(( VAR_HY2_BW * loss_compensation / 100 / 8 ))      
    [ "$g_wnd" -lt 15 ] && g_wnd=15  
    g_buf=$(( dyn_buf / 6 ))         
    # 5. 确定系统全局 UDP 限制
    udp_mem_global_min=$(( dyn_buf >> 12 ))
    udp_mem_global_pressure=$(( (dyn_buf << 1) >> 12 ))  # 2倍压力线
    udp_mem_global_max=$(( ((mem_total << 20) * 75 / 100) >> 12 ))   # 物理红线 75%
    max_udp_pages=$(( max_udp_mb << 8 ))
    # 6. 确定网卡调度预算
    local base_budget=$(( VAR_HY2_BW * 15 / 10 * 10 ))  
    [ "$base_budget" -lt 2000 ] && base_budget=2000
    [ "$base_budget" -gt 6000 ] && base_budget=6000
    [ "$real_c" -ge 2 ] && { net_bgt=$base_budget; net_usc=2000; } || { net_bgt=$(( base_budget << 1 )); net_usc=6000; }
    # 7. 内存保命机制：动态预留内核紧急水位 (vm.min_free_kbytes)
    local min_free_val=$(( mem_total * 1024 * 5 / 100 ))  # 提升到 5%
    # 针对 100M- 机器预留更多缓冲带（约 8-10MB），防止系统卡死
    [ "$mem_total" -lt 100 ] && min_free_val=$(( min_free_val * 2 ))
    [ "$min_free_val" -lt 8192 ] && [ "$mem_total" -lt 100 ] && min_free_val=8192 
    [ "$min_free_val" -lt 4608 ] && min_free_val=4608      
    if [ "$mem_total" -gt 100 ]; then [ "$min_free_val" -gt 65536 ] && min_free_val=65536; fi
	# 9. 路况仲裁
    safe_rtt "$dyn_buf" "$rtt_avg" "$max_udp_pages" "$udp_mem_global_min" "$udp_mem_global_pressure" "$udp_mem_global_max" "$real_rtt_factors" "$loss_compensation"
    UDP_MEM_SCALE="$rtt_scale_min $rtt_scale_pressure $rtt_scale_max"
	apply_initcwnd_optimization "false"
    apply_userspace_adaptive_profile "$g_procs" "$g_wnd" "$g_buf" "$real_c" "$mem_total"
    apply_nic_core_boost "$real_c" "$net_bgt" "$net_usc" "$mem_total" "$target_qlen" "$t_usc" "$ring"
    info "优化定档: $SBOX_OPTIMIZE_LEVEL | 带宽: ${VAR_HY2_BW} Mbps"
    info "网络蓄水池 (dyn_buf): $(( dyn_buf / 1024 / 1024 )) MB"
	
    # 阶段三： BBR 探测与调度器锁定 (动态适配小鸡环境)
    local tcp_cca="cubic"; local qdisc_algo="fq_codel" 
    modprobe tcp_bbr tcp_bbr2 tcp_bbr3 >/dev/null 2>&1 || true
    local avail=$(sysctl -n net.ipv4.tcp_available_congestion_control 2>/dev/null || echo "cubic")
    if [ ! -w "/proc/sys/net/ipv4/tcp_congestion_control" ]; then
        tcp_cca=$(sysctl -n net.ipv4.tcp_congestion_control 2>/dev/null || echo "cubic")
        warn "内核参数已锁定，维持系统默认算法: $tcp_cca"
    elif [[ "$avail" =~ "bbr3" ]]; then tcp_cca="bbr3"; qdisc_algo="fq"; succ "检测到 BBRv3，激活极致响应模式"
    elif [[ "$avail" =~ "bbr2" ]]; then tcp_cca="bbr2"; qdisc_algo="fq"; succ "检测到 BBRv2，激活平衡加速模式"
    elif [[ "$avail" =~ "bbr" ]]; then tcp_cca="bbr"; qdisc_algo="fq"; info "检测到 BBRv1，激活标准加速模式"
    else qdisc_algo="fq_codel"; warn "内核不支持 BBR，切换至高兼容 fq_codel 流量整形模式"; fi
    [ -w "/proc/sys/net/core/default_qdisc" ] && sysctl -w net.core.default_qdisc=$qdisc_algo >/dev/null 2>&1
    info "网络调度器已切换为: $qdisc_algo"
	
    # 阶段四： 写入 Sysctl 配置到 /etc/sysctl.d/99-sing-box.conf（避免覆盖 /etc/sysctl.conf）
    local SYSCTL_FILE="/etc/sysctl.d/99-sing-box.conf"
    cat > "$SYSCTL_FILE" <<SYSCTL
# === 一、 基础转发与内存管理 (含 ZRAM 与 OOM 策略) ===
net.ipv4.ip_forward = 1                    # 开启 IPv4 转发
net.ipv6.conf.all.forwarding = 1           # 开启 IPv6 转发
net.ipv6.conf.all.accept_ra = 2            # 强制接受 RA (解决转发模式下 IPv6 掉线)
net.ipv6.conf.default.accept_ra = 2        # 默认接受 RA
vm.swappiness = $swappiness_val            # 交换分区权重 (根据内存动态调整)
vm.min_free_kbytes = $min_free_val         # 强制预留水位 (防高并发内核卡死)
vm.dirty_ratio = 10                        # 内存脏数据占比上限
vm.dirty_background_ratio = 5              # 脏数据后台写入阈值
vm.overcommit_memory = 1                   # 允许内存超额分配
vm.panic_on_oom = 0                        # 内存溢出时不崩溃系统
$(grep -q "^/dev/zram0 " /proc/swaps 2>/dev/null && cat <<ZRAM_TUNING
vm.page-cluster = 0                        # ZRAM环境下禁用预读 (提升随机读写)
vm.vfs_cache_pressure = 1000                # 积极回收文件缓存 (为网络腾内存)
ZRAM_TUNING
)

# === 二、 网络设备层与 CPU 调度 (核心网卡加速) ===
net.core.netdev_max_backlog = $VAR_BACKLOG # 接收队列深度 (防突发丢包)
net.core.dev_weight = 64                   # CPU 单次收包权重
net.core.busy_read = $busy_poll_val        # 繁忙轮询 (降低收包延迟)
net.core.busy_poll = $busy_poll_val        # 繁忙轮询 (针对UDP优化)
net.core.somaxconn = 8192                  # 监听队列上限
net.core.default_qdisc = $qdisc_algo       # BBR必备调度规则
net.core.netdev_budget = $net_bgt          # 调度预算 (单次轮询处理包数)
net.core.netdev_budget_usecs = $net_usc    # 调度时长 (单次轮询微秒上限)
net.core.netdev_tstamp_prequeue = 0        # 禁用时间戳预处理 (降延迟)

# === 三、 协议栈缓冲与自适应加速 (TCP/UDP/BBR/MTU) ===
# --- 全局缓冲区限制 ---
net.core.rmem_default = $VAR_DEF_MEM       # 默认读缓存
net.core.wmem_default = $VAR_DEF_MEM       # 默认写缓存
net.core.rmem_max = $VAR_UDP_RMEM          # 最大读缓存 (支撑高带宽)
net.core.wmem_max = $VAR_UDP_WMEM          # 最大写缓存 (支撑高带宽)
net.core.optmem_max = 2097152              # Socket辅助内存上限
net.ipv4.udp_mem = $UDP_MEM_SCALE          # UDP 全局内存配额 (动态调节)
net.ipv4.tcp_rmem = 4096 87380 $tcp_rmem_max   # TCP 读缓存动态范围
net.ipv4.tcp_wmem = 4096 65536 $tcp_rmem_max   # TCP 写缓存动态范围

# --- 协议栈深度调优 (Hy2 传输核心) ---
net.ipv4.tcp_congestion_control = $tcp_cca # 拥塞算法 (BBR/Cubic)
net.ipv4.tcp_ecn = 1                       # 开启显式拥塞通知
net.ipv4.tcp_ecn_fallback = 1              # ECN 不兼容时自动回退
net.ipv4.tcp_no_metrics_save = 1           # 实时探测不记忆旧值
net.ipv4.tcp_fastopen = 3                  # 开启 TCP 快开 (降首包延迟)
net.ipv4.tcp_notsent_lowat = 16384         # 限制发送队列 (防延迟抖动)
net.ipv4.tcp_mtu_probing = 1               # MTU自动探测 (防UDP黑洞)
net.ipv4.ip_no_pmtu_disc = 0               # 启用路径MTU探测 (寻找最优包大小)
net.ipv4.tcp_frto = 2                      # 丢包环境重传判断优化
net.ipv4.tcp_slow_start_after_idle = 0     # 闲置后慢启动开关
net.ipv4.tcp_limit_output_bytes = $([ "$mem_total" -ge 200 ] && echo "262144" || echo "131072") # 限制TCP连接占用发送队列
net.ipv4.udp_gro_enabled = 1               # UDP 分段聚合 (降CPU负载)
net.ipv4.udp_early_demux = 1               # UDP 早期路由优化
net.ipv4.udp_l4_early_demux = 1            # UDP 四层早期分流
$(if [[ "$tcp_cca" == "bbr3" ]]; then echo "net.ipv4.tcp_ecn = 2"; echo "net.ipv4.tcp_reflect_tos = 1"; fi)

# === 四、 连接跟踪与超时管理 (及低内存保护) ===
net.netfilter.nf_conntrack_max = $ct_max   # 连接跟踪上限
net.netfilter.nf_conntrack_udp_timeout = $ct_udp_to           # 缩短无效连接回收
net.netfilter.nf_conntrack_udp_timeout_stream = $ct_stream_to # 优化流连接回收
net.ipv4.tcp_fin_timeout = 20              # 孤儿连接回收时间
net.ipv4.tcp_tw_reuse = 1                  # 端口重用
net.ipv4.tcp_max_orphans = $((mem_total * 1024)) # 最大孤儿连接数限制

$([ "$mem_total" -lt 100 ] && cat <<LOWMEM
# --- 针对 96M 小鸡的极低内存保护策略 ---
net.ipv4.tcp_sack = 1                      # 禁用SACK (省内存)
net.ipv4.tcp_dsack = 1                     # 禁用D-SACK
net.ipv4.tcp_timestamps = 1                # 禁用时间戳 (省包头开销)
net.ipv4.tcp_moderate_rcvbuf = 1           # 锁定手动缓冲区 (防内核抢占)
net.ipv4.tcp_max_syn_backlog = 512         # 缩减握手队列
LOWMEM
)
SYSCTL
    # 加载配置（优先 sysctl --system，其次回退）
	if command -v sysctl >/dev/null 2>&1 && sysctl --system >/dev/null 2>&1; then :
	else sysctl -p "$SYSCTL_FILE" >/dev/null 2>&1 || true; fi
}

# ==========================================
# 安装/更新 Sing-box 内核
# ==========================================
install_singbox() {
    # 1. 初始化：TD 去掉 local 确保全局可见，防止 set -u 报错；其余变量保持局部化
    TD="/var/tmp/sb_build"; local MODE="${1:-install}" LOCAL_VER="未安装" LATEST_TAG="" DOWNLOAD_SOURCE="GitHub" TF="$TD/sb.tar.gz" dl_ok=false best_link="" SBOX_ARCH="${SBOX_ARCH:-amd64}"
    [ -f /usr/bin/sing-box ] && LOCAL_VER=$(/usr/bin/sing-box version 2>/dev/null | head -n1 | awk '{print $3}')
    info "获取 Sing-Box 最新版本信息..."
    RJ=$(curl -sL --connect-timeout 10 --max-time 15 "https://api.github.com/repos/SagerNet/sing-box/releases/latest" 2>/dev/null || echo "")
    LATEST_TAG=$(echo "$RJ" | grep -oE '"tag_name"[[:space:]]*:[[:space:]]*"v[0-9.]+"' | head -n1 | cut -d'"' -f4 || echo "")
    [ -z "$LATEST_TAG" ] && { DOWNLOAD_SOURCE="官方镜像"; LATEST_TAG=$(curl -sL --connect-timeout 10 "https://sing-box.org/" 2>/dev/null | grep -oE 'v1\.[0-9]+\.[0-9]+' | head -n1 || echo ""); }
    [ -z "$LATEST_TAG" ] && { [ "$LOCAL_VER" != "未安装" ] && { warn "远程获取失败，保持 v$LOCAL_VER"; return 0; } || { err "获取版本失败"; exit 1; }; }
    
    local REMOTE_VER="${LATEST_TAG#v}"
    if [[ "$MODE" == "update" ]]; then
        echo -e "---------------------------------\n当前已装版本: \033[1;33m${LOCAL_VER}\033[0m\n官方最新版本: \033[1;32m${REMOTE_VER}\033[0m (源: $DOWNLOAD_SOURCE)\n---------------------------------"
        [[ "$LOCAL_VER" == "$REMOTE_VER" ]] && { succ "内核已是最新版本"; return 1; }
        info "发现新版本，开始下载更新..."
    fi

    # 2. 强化并行探测逻辑
    local FILE="sing-box-${REMOTE_VER}-linux-${SBOX_ARCH}.tar.gz"
    local URL="https://github.com/SagerNet/sing-box/releases/download/${LATEST_TAG}/${FILE}"
    rm -rf "$TD" && mkdir -p "$TD" && local LINKS=("$URL" "https://ghproxy.net/$URL" "https://kkgh.tk/$URL" "https://gh.ddlc.top/$URL" "https://gh-proxy.com/$URL")
    info "正在筛选最优下载节点 (并行模式)..."
    for LINK in "${LINKS[@]}"; do (curl -Is --connect-timeout 4 --max-time 6 "$LINK" 2>/dev/null | grep -q "200 OK" && echo "$LINK" >> "$TD/nodes") & done
    wait
    best_link=$( [ -s "$TD/nodes" ] && head -n1 "$TD/nodes" || echo "${LINKS[0]}" )
    
    # 3. 稳健下载逻辑
    info "选定节点: $(echo "$best_link" | cut -d'/' -f3)，启动下载..."
    { curl -fkL --connect-timeout 15 --retry 2 "$best_link" -o "$TF" && [ "$(stat -c%s "$TF" 2>/dev/null || echo 0)" -gt 5000000 ]; } && dl_ok=true || {
        warn "首选源失效，遍历备用源..."; for LINK in "${LINKS[@]}"; do
            info "尝试源: $(echo "$LINK" | cut -d'/' -f3)..."
            curl -fkL --connect-timeout 10 --max-time 60 "$LINK" -o "$TF" && [ "$(stat -c%s "$TF" 2>/dev/null || echo 0)" -gt 5000000 ] && { dl_ok=true; break; }
        done
    }
    [ "$dl_ok" = false ] && { [ "$LOCAL_VER" != "未安装" ] && { warn "所有源失效，保留旧版"; rm -rf "$TD"; return 0; } || { err "下载失败"; exit 1; }; }

    # 4. 覆盖安装：先删后移防二进制忙
    info "正在解压并准备安装内核..."
    { tar -xf "$TF" -C "$TD" >/dev/null 2>&1 && NEW_BIN=$(find "$TD" -type f -name "sing-box" | head -n1); } || { rm -rf "$TD"; err "解压失败"; return 1; }
    if [ -f "$NEW_BIN" ]; then
        chmod 755 "$NEW_BIN" && rm -f /usr/bin/sing-box && mv -f "$NEW_BIN" /usr/bin/sing-box
        pgrep -x sing-box >/dev/null && { info "热重启服务中..."; service_ctrl restart >/dev/null 2>&1 || { service_ctrl stop; sleep 1; service_ctrl start; }; }
        local VER=$(/usr/bin/sing-box version 2>/dev/null | head -n1 | awk '{print $3}')
        rm -rf "$TD" && succ "内核安装成功: v$VER"
    else rm -rf "$TD" && err "校验失败：二进制文件缺失" && return 1; fi
}

# ==========================================
# 配置文件生成
# ==========================================
create_config() {
    local PORT_HY2="${1:-}"; local PORT_REALITY="${2:-}"; local A_DOMAIN="${ARGO_DOMAIN:-}"; local A_TOKEN="${ARGO_TOKEN:-}"; local cur_bw="${VAR_HY2_BW:-200}"
    mkdir -p /etc/sing-box/certs
    local ds="ipv4_only"; local PSK=""; 
    [ "${IS_V6_OK:-false}" = "true" ] && ds="prefer_ipv4"
    local mem_total=$(probe_memory_total); : ${mem_total:=64}; local timeout="30s"
    local dns_srv='{"address":"8.8.4.4","detour":"direct-out"},{"address":"1.1.1.1","detour":"direct-out"}'
    [ "$mem_total" -ge 100 ] && timeout="40s" && dns_srv='{"tag":"cloudflare-doh","address":"https://1.1.1.1/dns-query","detour":"direct-out"},{"tag":"google-doh","address":"https://8.8.8.8/dns-query","detour":"direct-out"}'
    [ "$mem_total" -ge 200 ] && timeout="60s"; [ "$mem_total" -ge 450 ] && timeout="80s"

    # 1. 端口确定逻辑 (保持不变)
    if [ -z "$PORT_HY2" ] || [ "$PORT_HY2" == "current" ]; then
        if [ -f /etc/sing-box/config.json ]; then PORT_HY2=$(jq -r '.. | objects | select(.type == "hysteria2") | .listen_port' /etc/sing-box/config.json 2>/dev/null | head -n 1); fi
        [ -z "$PORT_HY2" ] && PORT_HY2=$(printf "\n" | prompt_for_port | awk '{print $1}')
    fi
    if [ -z "$PORT_REALITY" ] || [ "$PORT_REALITY" == "current" ]; then
        if [ -f /etc/sing-box/config.json ]; then PORT_REALITY=$(jq -r '.. | objects | select(.tag == "vless-reality-in") | .listen_port' /etc/sing-box/config.json 2>/dev/null | head -n 1); fi
        [ -z "$PORT_REALITY" ] && PORT_REALITY=$((PORT_HY2 + 3))
    fi

    # 2. PSK 与密钥处理
    local p_key="" s_id="" c_p="/etc/sing-box/certs/reality_priv.txt"
	mkdir -p /etc/sing-box/certs
    [ -f /etc/sing-box/config.json ] && {
        PSK=$(jq -r '..|objects|select(.type=="hysteria2")|.users[0].password//empty' /etc/sing-box/config.json | head -1)
        p_key=$(jq -r '..|objects|select(.tag=="vless-reality-in")|.tls.reality.private_key//empty' /etc/sing-box/config.json | head -1)
        s_id=$(jq -r '..|objects|select(.tag=="vless-reality-in")|.tls.reality.short_id[0]//empty' /etc/sing-box/config.json | head -1)
    }
    [ -z "$p_key" ] && [ -f "$c_p" ] && p_key=$(cat "$c_p" | tr -d '[:space:]')
    [ -z "$PSK" ] && PSK=$(cat /proc/sys/kernel/random/uuid 2>/dev/null || openssl rand -hex 16 | sed 's/^\(........\)\(....\)\(....\)\(....\)\(............\)$/\1-\2-\3-\4-\5/')
    if [ -z "$p_key" ]; then
        local kp=$(/usr/bin/sing-box generate reality-keypair)
        p_key=$(echo "$kp" | awk '/Priv/{print $NF}'); s_id=$(openssl rand -hex 8)
		echo "$(echo "$kp" | awk '/Pub/{print $NF}')" > /etc/sing-box/certs/reality_pub.txt
    fi
    [ -n "$p_key" ] && echo "$p_key" > "$c_p" && chmod 600 "$c_p"
    # 3. Hysteria2 证书救火逻辑
    if [ ! -f "/etc/sing-box/certs/fullchain.pem" ]; then
        openssl req -x509 -nodes -newkey rsa:2048 -keyout /etc/sing-box/certs/privkey.pem -out /etc/sing-box/certs/fullchain.pem -subj "/CN=${TLS_DOMAIN:-www.microsoft.com}" -days 3650 >/dev/null 2>&1
    fi

    # 4. 构造 Inbounds (采用标准逗号拼接逻辑)
    local INBOUNDS_JSON=""
    # --- Hy2 完整逻辑 ---
    local HY2_IN=$(printf '{
      "type": "hysteria2", "tag": "hy2-in", "listen": "::", "listen_port": %s, "users": [ { "password": "%s" } ],
      "ignore_client_bandwidth": false, "up_mbps": %s, "down_mbps": %s, "udp_timeout": "%s", "udp_fragment": true,
      "tls": {
        "enabled": true, "server_name": "%s", "alpn": ["h3"], "min_version": "1.3", 
        "certificate_path": "/etc/sing-box/certs/fullchain.pem", 
        "key_path": "/etc/sing-box/certs/privkey.pem"
      },
      "masquerade": "https://%s"
    }' "$PORT_HY2" "$PSK" "$cur_bw" "$cur_bw" "$timeout" "${TLS_DOMAIN:-www.microsoft.com}" "${TLS_DOMAIN:-www.microsoft.com}")
    INBOUNDS_JSON="$HY2_IN"

    # Reality Inbound
    local DOMAINS=("www.microsoft.com" "www.apple.com" "www.ebay.com" "www.icloud.com" "www.paypal.com")
	local REALITY_DEST=${DOMAINS[$RANDOM % ${#DOMAINS[@]}]}
    local REALITY_IN=$(printf '{
      "type": "vless", "tag": "vless-reality-in", "listen": "::", "listen_port": %s,
      "users": [ { "uuid": "%s", "flow": "xtls-rprx-vision" } ],
      "tls": {
        "enabled": true, "server_name": "%s",
        "reality": {
          "enabled": true, "handshake": { "server": "%s", "server_port": 443 }, "private_key": "%s", "short_id": ["%s"]
        }
      }
    }' "$PORT_REALITY" "$PSK" "$REALITY_DEST" "$REALITY_DEST" "$p_key" "${s_id:-a9aebdb4f9e42621}")
    INBOUNDS_JSON="$INBOUNDS_JSON, $REALITY_IN"

    # Argo Inbound (内建/外部双模式)
    if [ -n "$A_TOKEN" ] && [ -n "$A_DOMAIN" ]; then
        local ARGO_IN=""
        if [ "${USE_EXTERNAL_ARGO:-false}" = "true" ]; then
		    # 外部模式：必须指定 listen 为 127.0.0.1，防止外部扫描到该端口
            ARGO_IN=$(printf '{
              "type": "vless", "tag": "vless-argo-in", "listen": "127.0.0.1", "listen_port": 8001,
              "users": [ { "uuid": "%s", "flow": "" } ], "tls": { "enabled": false },
              "transport": { "type": "httpupgrade", "host": "%s" }
            }' "$PSK" "$A_DOMAIN")
        else
		    # 内建模式：内核自带 argo 驱动，不需要 listen 端口，它是主动连接 CF 的
            ARGO_IN=$(printf '{
              "type": "vless", "tag": "vless-argo-in", "server_name": "%s",
              "cloudflare": { "enabled": true, "tunnel": { "token": "%s" } },
              "users": [ { "uuid": "%s", "flow": "" } ], "tls": { "enabled": false },
              "transport": { "type": "httpupgrade", "host": "%s" }
            }' "$A_DOMAIN" "$A_TOKEN" "$PSK" "$A_DOMAIN")
        fi
        INBOUNDS_JSON="$INBOUNDS_JSON, $ARGO_IN"
    fi

    # 5. 写入 Sing-box 配置文件
    cat > "/etc/sing-box/config.json" <<EOF
{
  "log": { "level": "info", "timestamp": true },
  "dns": { "servers":[$dns_srv], "strategy":"$ds", "independent_cache":true, "disable_cache":false, "disable_expire":false },
  "inbounds": [ $INBOUNDS_JSON ],
  "outbounds": [ 
    { "type": "direct", "tag": "direct-out", "domain_strategy": "$ds" }
  ]
}
EOF
    chmod 600 "/etc/sing-box/config.json"
}

# ==========================================
# 服务配置
# ==========================================
setup_service() {
    local real_c="$CPU_CORE" core_range="" pid=""
    local taskset_bin=$(command -v taskset 2>/dev/null || echo "taskset")
    local ionice_bin=$(command -v ionice 2>/dev/null || echo "")
    local cur_nice="${VAR_SYSTEMD_NICE:--5}"; local io_class="${VAR_SYSTEMD_IOSCHED:-best-effort}"
    local mem_total=$(probe_memory_total); local io_prio=4
    [ "$real_c" -le 1 ] && core_range="0" || core_range="0-$((real_c - 1))"
    [ "$mem_total" -ge 450 ] && [ "$io_class" = "realtime" ] && io_prio=0 || io_prio=4
    [ "$mem_total" -lt 200 ] && io_prio=7
    local final_nice="$cur_nice"
    info "配置服务 (核心: $real_c | 绑定: $core_range | Nice预设: $cur_nice)..."
    if ! renice "$cur_nice" $$ >/dev/null 2>&1; then
        warn "当前环境禁止高优先级调度，已自动回退至默认权重 (Nice 0)"
        final_nice=0
    fi
    if [ "$OS" = "alpine" ]; then
        command -v taskset >/dev/null || apk add --no-cache util-linux >/dev/null 2>&1
        cat > /etc/init.d/sing-box <<EOF
#!/sbin/openrc-run
name="sing-box"
description="Sing-box Service"
supervisor="supervise-daemon"
respawn_delay=10
respawn_max=5
respawn_period=60
[ -f /etc/sing-box/env ] && . /etc/sing-box/env
export GOTRACEBACK=none
command="/usr/bin/sing-box"
command_args="run -c /etc/sing-box/config.json"
command_background="yes"
pidfile="/run/\${RC_SVCNAME}.pid"
supervise_daemon_args="--nicelevel ${final_nice}"
rc_ulimit="-n 1000000"
rc_nice="${final_nice}"
rc_oom_score_adj="-500"
depend() { need net; after firewall; }
start_pre() { /usr/bin/sing-box check -c /etc/sing-box/config.json >/tmp/sb_err.log 2>&1 || { echo "Config check failed:" && cat /tmp/sb_err.log && return 1; }; }
EOF
        chmod +x /etc/init.d/sing-box
        rc-update add sing-box default >/dev/null 2>&1 || true
        sync   # 确保环境文件与服务脚本落盘，防止启动瞬时读取失败
		(rc-service sing-box restart >/dev/null 2>&1 || true) &
    else
        local io_config=""; local ionice_class=2; local mem_config=""; local cpu_quota=$((real_c * 100))
        [ "$io_class" = "realtime" ] && ionice_class=1
        if ionice -c ${ionice_class} -n ${io_prio} true >/dev/null 2>&1; then
            io_config="IOSchedulingClass=${io_class}"$'\n'"IOSchedulingPriority=${io_prio}"
        fi
        [ "$cpu_quota" -lt 100 ] && cpu_quota=100
        [ -n "$SBOX_MEM_HIGH" ] && mem_config="MemoryHigh=$SBOX_MEM_HIGH"$'\n'
        [ -n "$SBOX_MEM_MAX" ] && mem_config+="MemoryMax=$SBOX_MEM_MAX"$'\n'
        local systemd_nice_line="Nice=${final_nice}"
        [ "${final_nice}" -eq 0 ] && systemd_nice_line="# Nice=0 (Environment restricted)"
        cat > /etc/systemd/system/sing-box.service <<EOF
[Unit]
Description=Sing-box Service
After=network-online.target
Wants=network-online.target
StartLimitIntervalSec=0
StartLimitBurst=3

[Service]
Type=simple
User=root
EnvironmentFile=-/etc/sing-box/env
Environment=GOTRACEBACK=none
ExecStartPre=/usr/bin/sing-box check -c /etc/sing-box/config.json
ExecStart=${taskset_bin} -c ${core_range} /usr/bin/sing-box run -c /etc/sing-box/config.json
${systemd_nice_line}
${io_config}
LimitNOFILE=1000000
LimitMEMLOCK=infinity
${mem_config}CPUQuota=${cpu_quota}%
OOMPolicy=continue
OOMScoreAdjust=-500
Restart=always
RestartSec=10s
TimeoutStopSec=15

[Install]
WantedBy=multi-user.target
EOF
        systemctl daemon-reload >/dev/null 2>&1
        systemctl enable sing-box >/dev/null 2>&1 || true
        sync   # 确保环境文件与服务配置落盘
		(systemctl restart sing-box >/dev/null 2>&1 || true) &
    fi
    set +e     # 关闭 set -e，这是防止脚本在 pidof 失败时直接退出的关键核心
    for i in {1..40}; do
        pid=$(pgrep -x "sing-box" 2>/dev/null | head -n 1)
        [ -z "${pid}" ] && pid=$(pgrep -f "sing-box run" | awk '{print $1}' | head -n 1)
        [ -n "${pid}" ] && [ -e "/proc/${pid}" ] && break
        sleep 0.3
    done
    # 异步补课逻辑。在进程确认拉起后，从脚本主体执行一次优化，这样既保证了优化生效，又不会因为优化脚本运行时间长而导致服务启动超时
    ([ -f "$SBOX_CORE" ] && /bin/bash "$SBOX_CORE" --apply-cwnd) >/dev/null 2>&1 &
	# --- 双进程外部 Argo 拉起逻辑 ---
    if [ "${USE_EXTERNAL_ARGO:-false}" = "true" ] && [ -n "${ARGO_TOKEN:-}" ]; then
        pkill -9 cloudflared >/dev/null 2>&1
        GOGC=30 nohup /usr/local/bin/cloudflared tunnel --protocol http2 --no-autoupdate --heartbeat-interval 10s --heartbeat-count 2 run --token "${ARGO_TOKEN}" >/dev/null 2>&1 &
    fi
    if [ -n "$pid" ] && [ -e "/proc/$pid" ]; then
        local ma=$(awk '/^MemAvailable:/{a=$2;f=1} /^MemFree:|Buffers:|Cached:/{s+=$2} END{print (f?a:s)}' /proc/meminfo 2>/dev/null)
        succ "sing-box 启动成功 | 总内存: ${mem_total:-N/A} MB | 可用: $(( ${ma:-0} / 1024 )) MB | 模式: $([[ "$INITCWND_DONE" == "true" ]] && echo "内核" || echo "应用层")"
    else
        err "服务拉起超时，请检查日志："
        [ "$OS" = "alpine" ] && { [ -f /var/log/messages ] && tail -n 10 /var/log/messages || logread | tail -n 10; } || journalctl -u sing-box -n 10 --no-pager 2>/dev/null
        set -e; exit 1
    fi
	set -e
}

# ==========================================
# 信息展示模块
# ==========================================
get_env_data() {
    local CFG="/etc/sing-box/config.json" RAW_ECH=""
    [ ! -f "$CFG" ] && return 1
    # 1. Hy2 数据
    local d=$(jq -r '..|objects|select(.type=="hysteria2")|(.users[0].password+" "+(.listen_port|tostring)+" "+.tls.certificate_path)//empty' "$CFG" 2>/dev/null | head -n 1)
    [ -z "$d" ] && return 1
    read -r RAW_PSK RAW_PORT CERT_PATH <<< "$d"
    # 2. Reality 数据
    local rd=$(jq -r '..|objects|select(.tag=="vless-reality-in")|((.listen_port|tostring)+" "+.tls.server_name+" "+.tls.reality.short_id[0])//empty' "$CFG" 2>/dev/null | head -n 1)
    if [ -n "$rd" ]; then
        read -r RAW_REA_PORT RAW_REA_SNI RAW_REA_SID <<< "$rd"
        RAW_REA_PBK=$([ -f "/etc/sing-box/certs/reality_pub.txt" ] && cat /etc/sing-box/certs/reality_pub.txt | tr -d '[:space:]' || {
            local priv=$(cat /etc/sing-box/certs/reality_priv.txt 2>/dev/null | tr -d '[:space:]')
            [ -n "$priv" ] && /usr/bin/sing-box generate reality-keypair -private-key "$priv" 2>/dev/null | awk '/Pub/{print $NF}'
        })
    fi
    # 3. Argo 数据
    RAW_ARGO_DOMAIN=$(jq -r '..|objects|select(.tag=="vless-argo-in")|(.transport.host//.server_name)//empty' "$CFG" 2>/dev/null | head -n 1)
    # 4. SNI & 指纹
    if [ -f "$CERT_PATH" ]; then
        RAW_SNI=$(openssl x509 -in "$CERT_PATH" -noout -subject -nameopt RFC2253 2>/dev/null | sed -n 's/.*CN=\([^,]*\).*/\1/p')
        [ -z "$RAW_SNI" ] && RAW_SNI="$TLS_DOMAIN"
        local F_P="/etc/sing-box/certs/cert_fingerprint.txt"
        RAW_FP=$([ -f "$F_P" ] && cat "$F_P" || openssl x509 -in "$CERT_PATH" -noout -sha256 -fingerprint 2>/dev/null | sed 's/.*=//;s/://g' | tr '[:upper:]' '[:lower:]')
    fi
    # 5. ECH 编码
    [ -f "/etc/sing-box/certs/ech.pub" ] && RAW_ECH=$(grep -v "ECH" "/etc/sing-box/certs/ech.pub" | tr -d '[:space:]' | sed 's/+/%%2B/g;s/\//%%2F/g;s/=/%%3D/g;s/%%/%/g')
}

display_links() {
    local LINK_V4="" LINK_V6="" LINK_REA="" LINK_ARGO="" FULL_CLIP="" hostname_tag="$(hostname)"
    # 数据准备 (通过 get_env_data 获取精准数据)
    get_env_data
    local HY2_PARAM="sni=$RAW_SNI&alpn=h3&insecure=1${RAW_FP:+&pinsha256=$RAW_FP}${RAW_ECH:+&ech=$RAW_ECH}"
	local p_hy2_text="\033[1;33m${RAW_PORT:-"未知"}\033[0m" p_rea_text="\033[1;33m${RAW_REA_PORT:-"关闭"}\033[0m" s_text="\033[1;33moffline\033[0m" 
    local hy2_icon="\033[1;31m[✖]\033[0m" rea_icon="\033[1;31m[✖]\033[0m" s_icon="\033[1;31m[✖]\033[0m"
    # 状态检测 (区分 UDP 与 TCP)，参数: $1=IP, $2=Port, $3=Mode(tcp/udp)
    _do_probe_v2() {
        [ -z "$1" ] || [ -z "$2" ] && return
        local mode_flag="-u"; [ "$3" == "tcp" ] && mode_flag=""
        (nc -z $mode_flag -w 1 "$1" "$2" || { sleep 0.3; nc -z $mode_flag -w 1 "$1" "$2"; }) >/dev/null 2>&1 && echo "OK" || echo "FAIL"
    }
    # 进程状态检测
    pgrep sing-box >/dev/null 2>&1 && { [ "${USE_EXTERNAL_ARGO:-false}" != "true" ] || pgrep cloudflared >/dev/null 2>&1; } && s_text="\033[1;33monline\033[0m" && s_icon="\033[1;32m[✔]\033[0m"
    # 执行并行端口扫描
    if command -v nc >/dev/null 2>&1; then
        _do_probe_v2 "${RAW_IP4:-}" "$RAW_PORT" "udp" > /tmp/sb_hy2_res 2>&1 &
        [ -n "$RAW_REA_PORT" ] && _do_probe_v2 "${RAW_IP4:-}" "$RAW_REA_PORT" "tcp" > /tmp/sb_rea_res 2>&1 &
        local t=0; while [ $t -lt 10 ] && pgrep -f "nc -z" >/dev/null 2>&1; do sleep 0.3; t=$((t+1)); done
        [ "$(cat /tmp/sb_hy2_res 2>/dev/null)" == "OK" ] && hy2_icon="\033[1;32m[✔]\033[0m"
        [ "$(cat /tmp/sb_rea_res 2>/dev/null)" == "OK" ] && rea_icon="\033[1;32m[✔]\033[0m"
    fi
    echo -e "\n\033[1;32m[节点信息]\033[0m >>> Hy2端口: $p_hy2_text $hy2_icon | Reality端口: $p_rea_text $rea_icon | 服务状态: $s_text $s_icon"
	
    # 1. Hysteria2 节点 (IPv4/IPv6)
    [ -n "${RAW_IP4:-}" ] && LINK_V4="hy2://$RAW_PSK@$RAW_IP4:$RAW_PORT/?${HY2_PARAM}#${hostname_tag}_Hy2_v4" && echo -e "\n\033[1;35m[IPv4 Hy2]\033[0m\n$LINK_V4" && FULL_CLIP="$LINK_V4"
    [[ "${RAW_IP6:-}" == *:* ]] && LINK_V6="hy2://$RAW_PSK@[$RAW_IP6]:$RAW_PORT/?${HY2_PARAM}#${hostname_tag}_Hy2_v6" && echo -e "\n\033[1;36m[IPv6 Hy2]\033[0m\n$LINK_V6" && FULL_CLIP="${FULL_CLIP:+$FULL_CLIP$'\n'}$LINK_V6"
    # 2. VLESS Reality 节点
    if [ -n "$RAW_REA_PORT" ]; then
        LINK_REA="vless://$RAW_PSK@$RAW_IP4:$RAW_REA_PORT?security=reality&sni=$RAW_REA_SNI&fp=chrome&pbk=$RAW_REA_PBK&sid=$RAW_REA_SID&type=tcp&flow=xtls-rprx-vision#${hostname_tag}_Reality"
        echo -e "\n\033[1;32m[VLESS Reality]\033[0m\n$LINK_REA"
        FULL_CLIP="${FULL_CLIP:+$FULL_CLIP$'\n'}$LINK_REA"
    fi
    # 3. Argo 隧道节点
    if [ -n "$RAW_ARGO_DOMAIN" ] && [ "$RAW_ARGO_DOMAIN" != "null" ]; then
        LINK_ARGO="vless://$RAW_PSK@$RAW_ARGO_DOMAIN:443?encryption=none&security=tls&sni=$RAW_ARGO_DOMAIN&type=httpupgrade&host=$RAW_ARGO_DOMAIN&fp=chrome#${hostname_tag}_Argo"
        echo -e "\n\033[1;33m[VLESS HttpUpgrade Argo]\033[0m\n$LINK_ARGO"
        FULL_CLIP="${FULL_CLIP:+$FULL_CLIP$'\n'}$LINK_ARGO"
    fi
    echo -e "\n\033[1;34m==========================================\033[0m"
    echo -e "\033[1;32m[安全增强]\033[0m 已启用 Hysteria2 + VLESS+Reality 双栈协议"
    [ -n "$RAW_ARGO_DOMAIN" ] && echo -e "\033[1;32m[隧道增强]\033[0m Argo 隧道已开启"
    [ -n "$FULL_CLIP" ] && copy_to_clipboard "$FULL_CLIP"
}

display_system_status() {
    local VER_INFO=$(/usr/bin/sing-box version 2>/dev/null | head -n1 | sed 's/version /v/')
    local ROUTE_DEF=$(ip route show default | head -n1)
    local CWND_VAL=$(echo "$ROUTE_DEF" | awk -F'initcwnd ' '{if($2){split($2,a," ");print a[1]}else{print "10"}}')
    local CWND_LBL=$(echo "$ROUTE_DEF" | grep -q "initcwnd" && echo "(已优化)" || echo "(默认)")
    local SBOX_PID=$(pgrep sing-box | head -n1)
    local NI_VAL="(未探测)"; local NI_LBL=""
    if [ -n "$SBOX_PID" ] && [ -f "/proc/$SBOX_PID/stat" ]; then
        NI_VAL=$(cat "/proc/$SBOX_PID/stat" | awk '{print $19}')
        [ "$NI_VAL" -lt 0 ] && NI_LBL="(进程优先)" || { [ "$NI_VAL" -gt 0 ] && NI_LBL="(低优先级)" || NI_LBL="(默认)"; }
    fi
    local current_cca=$(sysctl -n net.ipv4.tcp_congestion_control 2>/dev/null || echo "unknown")
    case "$current_cca" in bbr3) bbr_display="BBRv3 (极致响应)" ;; bbr2) bbr_display="BBRv2 (平衡加速)" ;; bbr) bbr_display="BBRv1 (标准加速)" ;; *) bbr_display="$current_cca (非标准)" ;; esac
	
    echo -e "系统版本: \033[1;33m$OS_DISPLAY\033[0m"
    echo -e "内核信息: \033[1;33m$VER_INFO\033[0m"
    echo -e "进程权重: \033[1;33mNice $NI_VAL $NI_LBL\033[0m"
    echo -e "Initcwnd: \033[1;33m$CWND_VAL $CWND_LBL\033[0m"
    echo -e "拥塞控制: \033[1;33m$bbr_display\033[0m"
    echo -e "优化级别: \033[1;32m${SBOX_OPTIMIZE_LEVEL:-未检测}\033[0m"
    echo -e "伪装SNI:  \033[1;33m${RAW_SNI:-未检测}\033[0m"
    echo -e "IPv4地址: \033[1;33m${RAW_IP4:-无}\033[0m"
    echo -e "IPv6地址: \033[1;33m${RAW_IP6:-无}\033[0m"
}

# ==========================================
# 管理脚本生成
# ==========================================
create_sb_tool() {
    mkdir -p /etc/sing-box
    local CORE_TMP=$(mktemp) || CORE_TMP="/tmp/core_script_$$.sh"
    # 写入固化变量
    cat > "$CORE_TMP" <<EOF
#!/usr/bin/env bash
set -uo pipefail
OS='$OS'; SBOX_ARCH='$SBOX_ARCH'; CPU_CORE='$CPU_CORE'; SBOX_CORE='$SBOX_CORE'
VAR_HY2_BW='${VAR_HY2_BW:-200}'; SBOX_GOLIMIT='$SBOX_GOLIMIT'
SBOX_GOGC='${SBOX_GOGC:-100}'; SBOX_MEM_MAX='$SBOX_MEM_MAX'
SBOX_MEM_HIGH='${SBOX_MEM_HIGH:-}'; SBOX_OPTIMIZE_LEVEL='$SBOX_OPTIMIZE_LEVEL'
INITCWND_DONE='${INITCWND_DONE:-false}'; VAR_SYSTEMD_NICE='${VAR_SYSTEMD_NICE:--5}'
VAR_SYSTEMD_IOSCHED='$VAR_SYSTEMD_IOSCHED'; OS_DISPLAY='$OS_DISPLAY'; TLS_DOMAIN='$TLS_DOMAIN'
RAW_SNI='${RAW_SNI:-$TLS_DOMAIN}'; RAW_ECH='${RAW_ECH:-}'
RAW_IP4='${RAW_IP4:-}'; RAW_IP6='${RAW_IP6:-}'; IS_V6_OK='${IS_V6_OK:-false}'
ARGO_DOMAIN='${ARGO_DOMAIN:-}'; ARGO_TOKEN='${ARGO_TOKEN:-}'
USE_EXTERNAL_ARGO='${USE_EXTERNAL_ARGO:-false}'
EOF
    # 导出函数
    local funcs=(probe_network_rtt probe_memory_total apply_initcwnd_optimization prompt_for_port
        get_cpu_core get_env_data display_links display_system_status detect_os copy_to_clipboard
        optimize_system install_singbox create_config setup_service apply_firewall service_ctrl info err warn succ
        apply_userspace_adaptive_profile apply_nic_core_boost verify_config
        setup_zrm_swap safe_rtt generate_cert setup_argo_logic)

    for f in "${funcs[@]}"; do
        if declare -f "$f" >/dev/null 2>&1; then declare -f "$f" >> "$CORE_TMP"; echo "" >> "$CORE_TMP"; fi
    done

    cat >> "$CORE_TMP" <<'EOF'
detect_os; set +e
apply_firewall
if [[ "${1:-}" == "--detect-only" ]]; then :
elif [[ "${1:-}" == "--show-only" ]]; then
    get_env_data; echo -e "\n\033[1;34m==========================================\033[0m"
    display_system_status; display_links
elif [[ "${1:-}" == "--reset-port" ]]; then
    f="/etc/sing-box/config.json"; cp "$f" "$f.bak"
    create_config "$2" "$3"
    if verify_config; then service_ctrl restart && succ "端口已重置并生效" && get_env_data && display_links && rm -f "$f.bak"
    else mv "$f.bak" "$f" && service_ctrl restart && err "已回滚至旧配置"; fi
elif [[ "${1:-}" == "--update-kernel" ]]; then
    if install_singbox "update"; then
        if verify_config; then service_ctrl restart && succ "内核已更新并重启服务"
        else err "新内核与当前配置不兼容，请检查配置或回退版本"; fi
    fi
elif [[ "${1:-}" == "--apply-cwnd" ]]; then
    apply_userspace_adaptive_profile >/dev/null 2>&1 || true
    apply_initcwnd_optimization "true" || true; apply_firewall
fi
EOF
    mv "$CORE_TMP" "$SBOX_CORE"
    chmod 700 "$SBOX_CORE"

    # 生成交互管理脚本 /usr/local/bin/sb
    local SB_PATH="/usr/local/bin/sb"
    cat > "$SB_PATH" <<'EOF'
#!/usr/bin/env bash
set -uo pipefail
SBOX_CORE="/etc/sing-box/core_script.sh"
if [ ! -f "$SBOX_CORE" ]; then echo "核心文件丢失"; exit 1; fi
[[ $# -gt 0 ]] && { /bin/bash "$SBOX_CORE" "$@"; exit 0; }
source "$SBOX_CORE" --detect-only

while true; do
    echo "========================" 
    echo " Sing-box HY2 管理 (sb)"
    echo "-------------------------------------------------"
    echo " Level: ${SBOX_OPTIMIZE_LEVEL:-未知} | Plan: $([[ "$INITCWND_DONE" == "true" ]] && echo "Initcwnd 15" || echo "应用层补偿")"
    echo "-------------------------------------------------"
    echo "1. 查看信息    2. 修改配置    3. 重置端口"
    echo "4. 更新内核    5. 重启服务    6. 卸载脚本"
    echo "0. 退出"
    echo ""  
    read -r -p "请选择 [0-6]: " opt
    opt=$(echo "$opt" | xargs echo -n 2>/dev/null || echo "$opt")
    if [[ -z "$opt" ]] || [[ ! "$opt" =~ ^[0-6]$ ]]; then
        echo -e "\033[1;31m输入有误 [$opt]，请重新输入\033[0m"; sleep 1; continue
    fi
    case "$opt" in
        1) source "$SBOX_CORE" --show-only; read -r -p $'\n按回车键返回菜单...' ;;
		2) f="/etc/sing-box/config.json"; old_md5=$(md5sum "$f" 2>/dev/null); cp "$f" "$f.bak"; vi "$f"
           if [ "$old_md5" != "$(md5sum "$f" 2>/dev/null)" ]; then
               if verify_config; then service_ctrl restart && succ "配置已更新，服务已重载" && rm -f "$f.bak"
               else warn "检测到语法错误，正在尝试回滚..."; mv "$f.bak" "$f" && service_ctrl restart && info "配置已还原，请再次尝试修改"; fi
           else info "配置未作变更" && rm -f "$f.bak"; fi
           read -r -p $'\n按回车键返回菜单...' ;;
        3) 
           echo -e "\n\033[1;34m端口重置管理\033[0m\n1. 重置 Hysteria2\n2. 重置 VLESS-Reality\n3. 返回主菜单"
           read -r -p "请选择: " opt
           case "$opt" in
               1) source "$SBOX_CORE" --reset-port "$(prompt_for_port)" "current" ;;
               2) source "$SBOX_CORE" --reset-port "current" "$(prompt_for_port)" ;;
               *) continue ;;
           esac
           read -r -p $'\n操作完成，按回车键返回...' ;;
        4) source "$SBOX_CORE" --update-kernel; read -r -p $'\n按回车键返回菜单...' ;;
        5) service_ctrl restart && info "系统服务和优化参数已重载"; read -r -p $'\n按回车键返回菜单...' ;;
		6) read -r -p "是否确定卸载？(默认N) [y/N]: " cf
           if [[ "${cf,,}" == "y" ]]; then
               info "正在执行深度卸载..."
               [ -f /etc/sing-box/config.json ] && RAW_PORT=$(grep '"listen_port":' /etc/sing-box/config.json | sed 's/[^0-9]//g')
               systemctl disable --now sing-box zram-swap 2>/dev/null; rc-service sing-box stop 2>/dev/null
               rm -rf /etc/sing-box /usr/bin/sing-box /usr/local/bin/{sb,SB,zram-swap} /etc/systemd/system/{sing-box,zram-swap}.service /etc/init.d/{sing-box,zram-swap} /etc/sysctl.d/99-sing-box.conf /tmp/sb_* ~/.acme.sh /swapfile
               [ -n "$RAW_PORT" ] && command -v iptables >/dev/null && { iptables -D INPUT -p udp --dport "$RAW_PORT" -j ACCEPT 2>/dev/null; ip6tables -D INPUT -p udp --dport "$RAW_PORT" -j ACCEPT 2>/dev/null; }
               sed -i '/net.ipv4.ip_forward/c\net.ipv4.ip_forward = 0' /etc/sysctl.conf 2>/dev/null || echo "net.ipv4.ip_forward = 0" >> /etc/sysctl.conf
               sed -i '/net.ipv6.conf.all.forwarding/c\net.ipv6.conf.all.forwarding = 0' /etc/sysctl.conf 2>/dev/null || echo "net.ipv6.conf.all.forwarding = 0" >> /etc/sysctl.conf
               sed -i '/vm.swappiness/c\vm.swappiness = 60' /etc/sysctl.conf 2>/dev/null || echo "vm.swappiness = 60" >> /etc/sysctl.conf
               sed -i '/swapfile/d' /etc/fstab; crontab -l 2>/dev/null | grep -v "acme.sh" | crontab - 2>/dev/null
               sysctl --system >/dev/null 2>&1; systemctl daemon-reload 2>/dev/null; succ "深度卸载完成，系统环境已重置"; exit 0
           else info "卸载操作已取消"; read -r -p "按回车键返回菜单..."; fi ;;
        0) exit 0 ;;
    esac
done
EOF
	chmod +x "$SB_PATH"
    ln -sf "$SB_PATH" "/usr/local/bin/SB" 2>/dev/null || true
}

# ==========================================
# 主运行逻辑
# ==========================================
detect_os
[ "$(id -u)" != "0" ] && err "请使用 root 运行" && exit 1
install_dependencies
CPU_CORE=$(get_cpu_core); export CPU_CORE
get_network_info; echo -e "-----------------------------------------------"
echo -e "\033[1;36m[配置]\033[0m 请设置 Hysteria2 端口"
PORT_HY2=$(prompt_for_port); echo -e "-----------------------------------------------"
echo -e "\033[1;36m[配置]\033[0m 请设置 VLESS-Reality 端口"
PORT_REALITY=$(prompt_for_port); echo -e "-----------------------------------------------"
setup_argo_logic; export ARGO_DOMAIN ARGO_TOKEN USE_EXTERNAL_ARGO; echo -e "-----------------------------------------------"
optimize_system
install_singbox "install"
generate_cert
create_config "$PORT_HY2" "$PORT_REALITY"
verify_config || exit 1
get_env_data
create_sb_tool
setup_service; echo -e "\n\033[1;34m==========================================\033[0m"
display_system_status; echo -e "\033[1;34m------------------------------------------\033[0m"
display_links
info "脚本部署完毕，输入 'sb' 管理"
